# Микросервис индексации RAG-системы

## Общее описание

Микросервис индексации принимает документы и метаданные, обрабатывает их через сервисы чанкинга и эмбеддинга, и сохраняет результаты в векторную базу данных Qdrant. Взаимодействие между сервисами осуществляется через gRPC.

## Архитектура

```
[ФайлМенеджер] -> [Индексер] -> [Чанкер] -> [Эмбеддер] -> [Qdrant]
```

## Функциональность

- Прием документов и метаданных через gRPC streaming
- Разбиение документов на чанки с помощью сервиса чанкинга
- Генерация эмбеддингов для чанков с помощью сервиса эмбеддинга
- Сохранение чанков, эмбеддингов и метаданных в Qdrant
- Поддержка батчевой обработки для оптимизации производительности
- Уникальная идентификация чанков с использованием UUID и резервного идентификатора
- Комплексная валидация и проверка безопасности входных данных
- Поддержка таймаутов для внешних вызовов

## Конфигурация

Конфигурация сервиса управляется через файл config.json:

```json
{
  "chunker_service": {
    "host": "localhost",
    "port": 50052
  },
  "embedder_service": {
    "host": "localhost",
    "port": 50051
  },
  "qdrant": {
    "host": "localhost",
    "port": 6333,
    "collection_name": "documents1024",
    "vector_size": 1024
  },
  "logging": {
    "level": "INFO",
    "file": "indexer.log"
  },
  "server": {
    "host": "localhost",
    "port": 50054,
    "max_workers": 1
  },
  "embedding_batch_size": 32,
  "chunk_size": 512,
  "chunk_overlap": 128,
  "security": {
    "max_content_size": 10485760,
    "max_filename_length": 255,
    "max_metadata_count": 50
  },
  "processing": {
    "embedder_timeout": 30.0,
    "max_chunks_per_doc": 1000
  }
}
```

Параметры конфигурации:
- `chunker_service.host/port` - адрес и порт сервиса чанкинга
- `embedder_service.host/port` - адрес и порт сервиса эмбеддинга
- `qdrant.host/port` - адрес и порт векторной базы данных Qdrant
- `qdrant.collection_name` - название коллекции в Qdrant
- `qdrant.vector_size` - размер вектора эмбеддинга
- `logging.level/file` - уровень логирования и имя файла лога
- `server.host/port` - хост и порт для запуска gRPC сервера
- `server.max_workers` - максимальное количество рабочих потоков
- `embedding_batch_size` - размер батча для генерации эмбеддингов
- `chunk_size` - размер чанка при разбиении документов
- `chunk_overlap` - размер перекрытия между чанками
- `security.max_content_size` - максимальный размер содержимого документа в байтах
- `security.max_filename_length` - максимальная длина имени файла
- `security.max_metadata_count` - максимальное количество элементов метаданных
- `processing.embedder_timeout` - таймаут для вызовов сервиса эмбеддинга
- `processing.max_chunks_per_doc` - максимальное количество чанков на один документ

## gRPC API

Сервис предоставляет метод `IndexDocument` с сигнатурой:

```
rpc IndexDocument(stream IndexFileRequest) returns (IndexResponse);
```

### Типы сообщений

- `IndexFileRequest`: Содержит заголовок с именем файла и метаданными, а также чанки содержимого файла
- `IndexResponse`: Содержит результат индексации (успех/неудача) и количество обработанных чанков

## Уникальная идентификация чанков

Для предотвращения конфликта идентификаторов между чанками разных документов используется следующая логика:

1. Если в метаданных присутствует ключ `doc_id`, он используется как идентификатор документа
2. Если `doc_id` отсутствует, используется имя файла
3. Если и имя файла недоступно, используется значение `unknown_doc`

Затем генерируется уникальный UUID на основе идентификатора документа и позиций начала/конца чанка:

```
chunk_id = uuid.uuid5(uuid.NAMESPACE_DNS, f"{doc_identifier}_{chunk.start}_{chunk.end}")
```

## Безопасность и валидация

Сервис реализует несколько уровней безопасности и валидации:

- Проверка размера содержимого документа (max_content_size)
- Проверка длины имени файла (max_filename_length)
- Проверка количества метаданных (max_metadata_count)
- Проверка безопасности имен файлов (validate_filename)
- Таймауты для внешних вызовов (embedder_timeout)
- Ограничение на количество чанков на документ (max_chunks_per_doc)
- Защита от атак с длинными именами файлов
- Защита от атак с избыточными метаданными
- Защита от атак с большими документами

## Запуск сервиса

```bash
python indexer.py
```

## Логирование

Логи записываются в stdout в соответствии с настройками.

## Тестирование

Для запуска сервиса:

```bash
python indexer.py
```